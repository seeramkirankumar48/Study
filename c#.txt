3.Boolean occupies 1 bit of memory,char occupies 16 bits
4.Verbatim literal eliminates the escape sequences and prints the statement as specified.
	cw(@"Hello\n123")--Hello\n123
6.to store the nullable types into the datatypes
	use:: int? i=null;
  By default the integral data types are not allowed to store the null values.
7.to convert the string datatypes to integer data types we can use int.Parse() or int.TryParse() Methods
	int.parse(string s)
	int.TryParse returns bool value whether the parsing is successful or not and stores the output in the out variable

	bool b=int.TryParse(string s,out result) 
8.Arrays are used to store the homogenous type of data
  Arrays once initialized cannot grow in size
  Arrays are strongly typed.
  int[] Arr=new int[3];
  Arr[0]=0;
  Arr[1]=1;
  Arr[2]=2;
  //initialize and assign in the same line.
  int[] Odd={1,3,5};
9.Single line comments -//
  multi line comments - /* */
  xml comments - ///
15.foreach is used to iterate through the collection
	foreach(int item in Arr)
	{
	cw(item);
	}
   //value is retrieved from Arr in each iteration and gets stored in the item.
17.different types of method parameters::
	value parameters:: creates a copy of the parameters
	reference parameters:: variables point to the same address
	out parameters::when there is more than one return value.
	Parameter arrays:: takes a variable number of parameters
	public void fun(params int[] arr)
	{
	//
	}
	fun() // Pass-without arguments
	fun(1,2,3) // Pass- List of arguments
	int[] arr=new int[3];
	fun(arr) //Pass-passing of array as an argument
 Note:: there should not be more than one params keyword in the method.
	if there are multiple arguments in the method then the params keyword should be the last one.
 Diff b/w ref and out keyword::
	for ref the values are initialized before the method calling and can be intialized in the method.
	for out the values should be initialized in the method.

18.Namespaces are used to Organize the Code.
   Namespaces are used to avoid name clashes.
	To avoid name clashes use
	1.Fully Qualified name ProjectA.TeamA.ClassA.Print();
	2.namespace Alias--using PATA=ProjectA.TeamA;
			   PATA.ClassA.Print();
   NameSpaces doesn't correspond to filename/assembly. They can be written in the separate files but belong to the same namespace.

19.Classes are used to create the Custom data types
   Constructors are used to intialize the class fields during creation of the object.
   Constructors donot have return Value and should have the same name of the class Name.
   By Default a default Constructor is provided by .NET compiler.
   If we provide our own only Constructor(parameterized) then the default constructor will not be provided by .NET, Eventhough if we
     want the default constructor then we need to create the default constructor explicitly.
   Constructors are overloaded by Number and type of parameters
   Calling of parameterized constructor by default constructor::
	class Customer
    {
        string firstName;
        string lastName;
        public Customer():this("no fname","no lname")
        {

        }
       
        public Customer(string fname,string lname)
        {
            this.firstName = fname;
            this.lastName = lname;
        }
        public void FullName()
        {
            Console.WriteLine("FullName ={0}",this.firstName+" "+this.lastName);
        }
    }

20.If something that was not changed on per object basis then it is wise to declare that field as static.If it was declared as static 
   then that particular field is shared across multiple objects results in performance of the application.
   Note: Static Constructor is used to initialize the static fields of the class.
	 Static Constructor is called once and only one time eventhough there are multiple class instances.
	 this keyword is not used to refer the static fields.
   	 Static Constructors are called even before the instance Constructors.
  	 Access modifiers("public","private") should not be used before the Static Constructors because they are called evenbefore 
	 the instantation of object.

21.Inheritance is used to allow code reuse.
	All the common code goes into the Base Class and specialized classes are "Derived" classes.
	A class can be inherited from another class using ':'
        class Parent
	{
	}
	class Child:Parent
	{
	}  
	While Creating of the Child Class object the Parent Class Constructor is called followed by child class constructor.
	Child Class is a specialized class of Parent Class(because it includes both child as well as parent class properties).
	C# doesn't Supports multiple class inheritance.
	to call the Base class specific constructor(parameterized) use "base" keyword for the child class Constructor
	class Program
    {
        static void Main(string[] args)
        {
            Child c = new Child("Kiran");
        }
    }

   class Parent
    {
        public Parent()
        {
            Console.WriteLine("Parent Class Default Constructor");
        }
        public Parent(string message):this()
        {
            
            Console.WriteLine("Parent Class parameterized Constructor"+message);
        }
    }
    class Child:Parent
    {
        public Child()
        {
            Console.WriteLine("Child Class Default Constructor");
        }
        public Child(string message2):base(message2)
        {
            
            Console.WriteLine("Child Class parameterized Constructor");
        }
    }

	o/p::Parent Class Default Constructor
	     Parent Class parameterized ConstructorKiran
	     Child Class parameterized Constructor

22.Method Hiding::when there are methods with the same name in both of the Parent class and Child class, the child class method 
		  hides the parent class method.
	There will be a warning if the hiding is intentional use new keyword to hide the child class method.
	while an object is created the child method is invoked cozz., the parent class method is hidden.
	to invoke the parent class method use::
	1.base.parentclass_method();
		 base.FullName();
		 //Console.WriteLine(this.firstName + " " + this.LastName + "-Contractor");
	2.casting the object reference of the child class with the parent class.
		  PTE pte = new ConsoleApplication2.PTE();
            	  pte.firstName = "Kiran";
            	  pte.LastName = "Seeram";
            
            	  ((Employee)pte).FullName();
	3.parent class reference variable pointing to the child class object.
		   Employee pte = new ConsoleApplication2.PTE();
            	   pte.firstName = "Kiran";
            	   pte.LastName = "Seeram";
            
            	   pte.FullName();

	//code
		class Program
    {
        static void Main(string[] args)
        {
            Employee pte = new ConsoleApplication2.PTE();
            pte.firstName = "Kiran";
            pte.LastName = "Seeram";
            
            pte.FullName();
        }
    }

    class Employee
    {
       public string firstName;
       public  string LastName;
        public void FullName()
        {
            Console.WriteLine(this.firstName+" "+this.LastName);
        }
    }

    class FTE : Employee
    {

    }
    class PTE:Employee
    {
        int hrlyRate;
        public new void FullName()
        {
            base.FullName();
            Console.WriteLine(this.firstName + " " + this.LastName + "-Contractor");
        }
    }

23.Polymorphism:: polymorphism enables us to get the derived class methods with the parent class reference variables during runtime.
	for this the parent class method needs to be virtual and child class methods needs to be override
	virtual keyword indicates that the methods in the derived class can be overrided if needed.
	class Program
    {
        static void Main(string[] args)
        {
            Employee[] employees = new Employee[3];
            employees[0] = new Employee();
            employees[1] = new FTE();
            employees[2] = new PTE();
            foreach(Employee emp in employees)
            {
                emp.FullName();
            }
            PTE pte = new ConsoleApplication2.PTE();
            pte.FullName();
        }
    }

    class Employee
    {
       public string firstName="FN";
       public  string LastName="LN";
        public virtual void FullName()
        {
            Console.WriteLine(this.firstName+" "+this.LastName);
        }
    }

    class FTE : Employee
    {

    }
    class PTE:Employee
    {
        int hrlyRate;
        public override void FullName()
        {
           
            Console.WriteLine(this.firstName + " " + this.LastName + "-Contractor");
        }
    }

24.Method overriding vs method hiding::
	method overriding::when a parent class reference variable points to the child class object the child class method is invoked
			   with the parent class reference variable(similar to polymorphism)
	method hiding::when a parent class reference variable points to the child class object the parent class method is invoked due
		       to which the parent class reference variable is pointing to the child class object even though the method is 
		       hidden in the derived class.

25.Method Overloading:: method overloading allows a class to have multiple functions with the same name.
	method overloading can happen with the number,type(data_type),kind(ref,out,Value) together called as signature.
	method overloading cannot happen with the return type and with params keyword.

26.Properties::
	Properties allows to set and get the field values without exposing them.
	Class Customer
	{
	 	public int Id;
		public string Name;
	}
	Customer c=new Customer();
	c.Id=-101;
	//user can set whatever value they want without restricting them.so to restrict and validate the date we can use either,
	1.getter and setter methods
	2.Properties
	and making the fields to private.
		//getter and setter
		public class Customer
{
    int Id;
    string name;
    public void SetId(int ID)
    {
        if (ID <= 0)
        {
            throw new Exception("Negative ID is not accepted");
        }
        this.Id = ID;
    }
    public int getId()
    {
        return this.Id;
    }
    public void setName(string Name)
    {
        if (string.IsNullOrEmpty(Name))
        {
            throw new Exception("Name cannot be null or Empty");
        }
        this.name = Name;
    }
    public string getName()
    {
        return this.name;
    }
}

//properties
public class Customer
{
    int Id;
    public int ID
    {
        set
        {
            if (value <= 0)
            {
                throw new Exception("Id cannot be negative");
            }
            else
            {
                this.Id = value;
            }
        }
        get
        {
            return this.Id;
        }
    }
    string name;
    //if no validations and Checking
       public string Name { set; get; }
    int passmark = 35;
    //read only field
    public int PassMark
    {
        get
        {
            return this.passmark;
        }
    }
    
}
	
	Note:: there can be read only/write only properties
	       If there are no validations for properties then public string Name{get;set;} .net will automatically create the 	       private fields during run time.

29.Structs are similar to classes but they have huge differences.
	Structs(including variables,enums,object reference variables) are stored on stack
	Objects(classes,delegates,Interfaces) are stored on Heap
	The struct values are stored as long as there is a scope for the variable.
	The reference for the object is lost where as the object remains in the Heap which is then cleaned by GC.
	During the copy of the variables:
	1.a new value of copy is created for structure data types.
	2.for reference types a new variable is created but both of them point to the same variable.
	circle c1=new circle();
	circle c2=c1;
	here c1 and c2 point to the same circle object. hence the object can be accessed by both of the variables.Either by c1 or c2.
	
	structs can't have destructors where as a class can.
	structs can't have explicit parameterless constructor.
	structs can't inherit from class.both struct and class can inherit from interfaces.
	A class or struct cannot inherit from another struct because they are sealed type.
	sealed types allow us to prevent a class from being inherited.

30.Interfaces:
	Interfaces have only declartions not implementations.
	Use of access modifier before the declaration is an CT error(because the class or struct which is inherited is guaranteed to
	provide the definition for it).Interface members are public by default.
	There are no fields in interfaces.
	A class can inherit from more than one interface (Multiple class inheritance is not supported.)
	A interface can inherit from an another interface but the class that is inheriting from that interface must provide the
	implementations for the entire interface chain.
	We cannot create objects for interfaces because they dont provide the implementation.

31.Explicit interface:
	If Two interfaces contain the method's with same name and if this interface methods want to implement there own methods then,
	we can use explicit interface.
	while implementing the explicit implementation there should not be any access modifiers in which the implemenation is 	provided.
	when a class has methods that are explictly implemented methods of interfaces then those cannot be called by object reference
	variables of the class.Instead they can be accessed by :: ((I1)A).fun();	//	((I2)A).fun();

	interface I1
	{
	void fun();
	}
	
	interface I2
	{
	void fun();
	}

	class A:I1,I2
	{
	void I1.fun()
	{
	
	}
	
	void I2.fun()
	{
	
	}
	}
	
	while calling the implemented methods use type casting:
	((I1)A).fun();
	It cannot be accessed by A.fun(); because compiler doesn't know which version of fun needs to be called.
	To make a default behavior of one version::explicitly implement one method and implement interface for one method
	
	interface I1
	{
	void fun();
	}
	
	interface I2
	{
	void fun();
	}

	class A:I1,I2
	{
	public void fun()
	{
	
	}
	
	void I2.fun()
	{
	
	}
	} 

	Default behavior of I1 is selected by calling A.fun();
	To call the I2 method use ((I2)A).fun();

32.Abstract class:
	A class can contain the abstract members(methods,properties) but not mandatory.
	An abstract class cannot be of sealed type.
	If a class inherits an abstract class it has 2 options::
	1.Implement the abstract methods of the base abstract class.
	2.Make the inherited class an abstract method then it will provide a compulsion that whatever the class again inheriting
	  this inherited class should implement all the abstract methods.
	We cannot create objects for abstract class hence we will use it as a base class::
	AbstractClass A= new InheritedClass
	A.Method();

33.Diff b/w Abstract and Interfaces::
	1.An abstract classes can inherit from another interface or class where as an interface can inherit from another interface.
	2.The default access modifier for abstract is private and for interface it is public.
	3.Abstract classes can have fields but interfaces cannot have.
	4.Abstract classes can have implementations but not the interfaces.

34.Problems of multiple class inheritance:
	when a class inherits from two classes and if those classes have the same method name then in the inherited class while
	creating the object and while calling the method with the same name,compiler is unable to decide the which version of the 
	method is to be called this usually defined to be an diamond problem.

35.multiple inheritance by interfaces::	
	since while inheriting there is an compulsion that inherited class should provide the implementation for the inherited 	members and interfaces also provide an explicit interface implementation so that they can have there own versions or even if
	not there own version an common method of implementation is provided so that it will serve the purpose of both the 	interfaces, so multiple inheritance is achieved by interfaces.


36.Delegate::A delegate is a type safe function pointer,i.e., a delegate signature must follow the same signature of the function 	     else will get an CT error.
	     By Using Delegates, we can pass function as a parameter.
	     We can pass the function as a parameter using the delegates.
	 public  delegate void MyDel(string strMessage);
    class Program
    {
        static void Main(string[] args)
        {
            MyDel del = new MyDel(GetMessage);
            del("Welcome!!!");
        }
        public static void GetMessage(string strMessage)
        {
            Console.WriteLine(strMessage);
        }
    }

37&38. delegate Program Sample::
	Here to promote an Employee we need to constantly change the code for criteria based onthe Employee associated with. 	irrespective of that this can be achieved with delegates.
	  class Program
    {
        static void Main(string[] args)
        {
            List<Employee> employees = new List<Employee>()
            {
                new Employee {Name="Kiran",Salary=10000,Age=23,Exp=2.2F },
                new Employee {Name="Uday",Salary=12000,Age=23,Exp=1.5F },
                new Employee {Name="Sandy",Salary=8000,Age=24,Exp=2.2F }
            };
            IsPromotable promote = new IsPromotable(Employee.PromoteBasedOnExperience);
            Employee.PromoteEmployees(employees, promote);

        }
    }


    public delegate bool IsPromotable(Employee emp);
    public class Employee
    {
        public string Name { set; get; }
        public int Salary { set; get; }
        public int Age { set; get; }
        public float Exp { set; get; }
        public static void PromoteEmployees(List<Employee> empList,IsPromotable promote)
        {
            foreach(Employee emp in empList)
            {
               if(promote(emp))
                {
                    Console.WriteLine("{0} is Promoted based on Salary",emp.Name);
                }
            }
        }

        public static bool PromoteBasedOnSalary(Employee emp)
        {
            if (emp.Salary >= 10000)
            {
                return true;
            }
            else
            {
                return false;
            }
        }

        public static bool PromoteBasedOnExperience(Employee emp)
        {
            if (emp.Exp >= 2.0)
            {
                return true;
            }
            else
            {
                return false;
            }
        }


    }


39.A multicast delegate is one which has references to more than one function.
	1.Multicast delegate invokes the methods in the invocation list in the same order in which they have added.
	2.To register a delegate use += to unregister use -=
	3.when a delegate methods return the return type other than void the last end result that was retrieved is the method in the
	last invocation list. on the similar lines it is same with the out parameter.
	public delegate int MyDelegate();
    class Program
    {
        static void Main(string[] args)
        {
            MyDelegate del = new MyDelegate(Method1);
            del += Method2;
            del += Method3;
            int result = del();
            Console.WriteLine("Last Result:{0}",result);

        }
        public static int Method1()
        {
            Console.WriteLine("Method1 Invocation");
            return 1;
        }
        public static int Method2()
        {
            Console.WriteLine("Method2 Invocation");
            return 2;
        }
        public static int Method3()
        {
            Console.WriteLine("Method3 Invocation");
            return 3;
        }
    }
	4.Mutlicast delegates are generally used in observer/design pattern.
	5.Delegates can be replaced by the lambda expressions.

40.Excepton Handling::
	An exception is an unforseen Error caused during runtime.
	Exceptions can be handled by try,catch,finally blocks.
	Exception(System.Exception) is the base class for all the Exception classes(FileNotFound,DirectoryNotFound,etc.,)
	whenever a statement encounters an exception in the try block and it will immediately searches for suitable catch block, and
	executes the further steps. In catch block generally the exceptions were logged in the Database.
	the must executable statements are kept in the finally block so that they are guaranteed to be executed(they are not when an
	exception occurs again in catch block and the finally code is not present in the finally block) generally the con.close() is 	closed in finally.
	The exception class in catch block is kept last in the catch block or else it will throw CT error because it will generalise 
	and guaranteed to be executed at first place.
	 class Program
    {
        static void Main(string[] args)
        {
            StreamReader str = null;
            try
            {
                str = new StreamReader(@"D:\Welcome1.txt");
            }
            catch(FileNotFoundException ex)
            {
                Console.WriteLine(ex.Message);
               
            
            }
            catch(Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
                str = new StreamReader(@"D:\Welcome1.txt");

            }
            Console.WriteLine("Outer");
            //Console.WriteLine(str.ReadToEnd());
            //str.Close();
        }
    }
	//ex.message prints the suitable error message // stacktrace tells at which line the error was occured.

41.Inner Exception::
		class Program
    {
        static void Main(string[] args)
        {

            int numerator;
            int denominator;
            try
            { 
            try
            {
                Console.WriteLine("Enter the Numerator:");
                numerator = Convert.ToInt32(Console.ReadLine());
                Console.WriteLine("Enter the Denominator:");
                denominator = Convert.ToInt32(Console.ReadLine());
                int result = numerator / denominator;
                Console.WriteLine("Result = {0}",result);
            }
            catch(Exception ex)
            {
                //Error Logging
                string fileName = @"D:\ErrorLog.txt";
                if(File.Exists(fileName))
                {
                    StreamWriter str = new StreamWriter(@"D:\ErrorLog.txt");
                    str.Write(ex.GetType().Name);
                    str.WriteLine();
                    str.Write(ex.Message);
                        Console.WriteLine("Exception logged in {0}",fileName);
                    str.Close();
                }
                else
                {
                    throw new FileNotFoundException("File Not found", ex);
                }
  
            }
            }
            catch(Exception exception)
            {
                Console.WriteLine("Current Exception={0}",exception.Message);
                if(exception.InnerException!=null) ///to check whether the inner exception is null
                Console.WriteLine("Last Exception={0}",exception.InnerException);
            }
           
        }
    }

42.CustomException::
			    class Program
    {
        static void Main(string[] args)
        {
            throw new UserAlreadyLoggedInException("UserAlready Logged In");
           
        }
    }

    [Serializable]
    public class UserAlreadyLoggedInException:Exception
    {
        public UserAlreadyLoggedInException():base()
        {
                
        }
        public UserAlreadyLoggedInException(string message):base(message)
        {

        }
        public UserAlreadyLoggedInException(string message,Exception ex):base(message,ex)
        {

        }

        public UserAlreadyLoggedInException(SerializationInfo info, StreamingContext context):base(info,context)
        {

        }
    }



44.Solving Exception Abuse::
			    class Program
    {
        static void Main(string[] args)
        {
            try
            {
                int numerator;
                int denominator;
                Console.WriteLine("Enter Numerator:");
                bool IsNumerator = int.TryParse(Console.ReadLine(), out numerator);
                Console.WriteLine("Enter Denominator:");
                bool IsDenominator = int.TryParse(Console.ReadLine(), out denominator);
                if (IsNumerator)
                {
                    if (IsDenominator && denominator != 0)
                    {
                        int result = numerator / denominator;
                        Console.WriteLine("Result = {0}", denominator);
                    }
                    else
                    {
                        if (!IsDenominator)
                        {
                            Console.WriteLine("Please Enter the Integer Value for Denominator");
                        }
                        else
                        {
                            Console.WriteLine("Denominator should not be zero");
                        }
                    }
                }
                else
                {
                    Console.WriteLine("Please Enter the Integer Value for Numerator");
                }

            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

    }

	1.while closing the connection objects check whether these objects are not null
		if(con!=null)
	2.while printing the inner exceptions check whether these objects are not null
		if(ex.InnerException!=null)





47.If a program uses set of integral values consider replacing them with enums this makes program more readable,maintainable.
	
		class Program
    {
        static void Main(string[] args)
        {
            Customer[] cust = new Customer[]{new Customer(){Name="Kiran",Gender=Gender.Male},
            new Customer(){Name="Vinny",Gender=Gender.Female}};

            //foreach (Customer item in cust)
            //{
            //    Console.WriteLine("Name = {0} && Gender= {1}",item.Name,Customer.GetGenderName(item.Gender));
            //}

            foreach (int item in Enum.GetValues(typeof(Gender)))
            {
                Console.WriteLine("Name = {0} && Value = {1}",Enum.GetName(typeof(Gender),item),item);
            }
        }
    }

    public enum Gender
    {
        Unknown,
        Male,
        Female
    }
    public class Customer
    {
        public string Name { set; get; }

        public Gender Gender { set; get; }

        public static string GetGenderName(Gender gender)
        {
            switch(gender)
            {
                case Gender.Unknown: return "UnKnown";
                case Gender.Male: return "Male";
                case Gender.Female: return "Female";
                default: return "Gender not known";
            }
        }
    }

	1.Enum:: enums are enumerations or enumeration is a named integer constant.
	2.Enum's are strongly typed constants hence an explicit cast is required.
		int[] values =(int[])(Enum.GetValues(typeof(Gender)));
	  We cannot Assign Enum of one type to the enum of another it is possible by explicit casting.
	3.The default underlying type of enum is int.
		to change the enum type use::
				   public enum Gender: short
    {
        Unknown,
        Male,
        Female
    }
	4.the default value is 0 and it is incremented by 1.
	5.enums are value types.
	6.the typeof keyword is used to get the type -- int,short of enum.


48.diff b/w types and type members::
	types:: class,enums,delegates,interfaces,structs
	typemembers: the members with in the types:: methods,ctors,properties,fields
	
	to expand/collapse a specific set of code include the code in the region.
	#region properties
	//consists of all the properties code//
	#endregion

	there are 5 types of access modifiers in c#
	1.public -- public is accessed every where
	2.private -- with in the containing type
	3.protected -- within the containing type and types that derive from the containing type
	4.internal -- in the whole assembly level.
	5.protected internal -- combination of internal and protected
	By default all the type members can have all the access modifiers -- default being private
	the types can have internal and public -- default being internal
	
52.Attributes::
 	Attributes are used to add the declarative information. ths info is used at runtime.
	class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(Calculator.Add(2,3));
        }

       
    }

    class Calculator
    {
        [Obsolete("use List<int> as this method is obsolete",true)] // the true includes that to raise 		the error or else a warning symbol is issued
        public static int Add(int fn,int sn)
        {
            return fn+sn;
        }
        public static int Add(List<int> numbers)
        {
            int sum = 0;
            foreach (int item in numbers)
            {
                sum += item;
            }
            return sum;
        }
    }

53.Reflections::
	Reflections are used to inspect the assemblies metadata at runtime.

	uses::
	1.while dragging the button from toolbox on to the designer in asp.net we will get all the 		properties list related to that button is the best example of reflection.
	2.reflections are used for latebinding.
	3.when there are different types of implemenatations and that particular implemenatation is 		read from config file. we can use reflection to this kind of a thing.

		namespace ConsoleApplication2
{
    class Program
    {
        static void Main(string[] args)
        {
            Type t = Type.GetType("ConsoleApplication2.Customer");
          
           //properties list
           PropertyInfo[] properties = t.GetProperties();
           foreach (PropertyInfo item in properties)
           {
               Console.WriteLine(item.PropertyType.Name + " "+item.Name);
           }
           
          Console.WriteLine();
          //ctors list
          ConstructorInfo[] constructors = t.GetConstructors();
          foreach (ConstructorInfo item in constructors)
          {
              Console.WriteLine(item.ToString());
          }

          Console.WriteLine();
          //methods list
          MethodInfo[] methods = t.GetMethods();
          foreach (MethodInfo item in methods)
          {
              Console.WriteLine(item.ReturnType.Name+" "+item.Name);
          }

        }
    }

    class Customer
    {
        public int custId { set; get; }
        public string fname { set; get; }

        public string lname { set; get; }

        public Customer()
        {
            this.custId = -1;
            this.fname = "Kiran";
            this.lname = "Seeram";
        }

        public Customer(string fname,string lname)
        {
            this.custId = 101;
            this.fname = fname;
            this.lname = lname;
        }

        public string GetFullName(string fname,string lname)
        {
            return this.fname + this.lname;
        }

        public void GetId()
        {
            Console.WriteLine(this.custId);
        }
    }
}


	//Type class is present inside the system namespace
	//to use all the methods of the Reflection use system.Reflection
	// to get the type
		1.Type t=Type.GetType("namespace.className")
		2.Type t = typeof(ClassName);
		3.Customer c1=new Customer();
		  Type t = c1.GetType();


55.Late Binding::








56.Generics are allowed us to design classes and methods decoupled    from data types.
	//Generics are available in System.Collections.Generic;
		   
    class Program
    {
        static void Main(string[] args)
        {
            bool equals = Calculator<string>.Compare("ab", "ab");
            Console.WriteLine(equals);
        }
        
    }

    class Calculator<T>
    {
        public static bool Compare(T a,T b)
        {
            return a.Equals(b);
        }
    }


	Note:: the above compare function can be replace by the function parameters object.
	By replacing with object type parameters there are 2 cons::
	1.there should be an suitable boxing and unboxing operations
	2.by calling the function 
	  //Compare(5,"string") --- the compare fun takes int and 	string and doesn't show any CT error.
	Hence, we will go for Generics.

57.Override tostring() Method::
	When we try to invoke (c.tostring()) the toString() method on the class instance it will return the namespace.classInstance_name
	class Program
    {
        static void Main(string[] args)
        {
            Customer c = new Customer();
            c.fname = "Kiran";
            c.lname = "seeram";
            Console.WriteLine(c.ToString()); //return 					ConsoleApplicaton2.Customer

        }
        
    }

    class Customer
    {
        public string fname { get; set; }

        public string lname { get; set; }

       
    }

	//If we want to override the tostring() method and want to provide the default behavior it is possible because each and every class inherits from base object class.
		   class Program
    {
        static void Main(string[] args)
        {
            Customer c = new Customer();
            c.fname = "Kiran";
            c.lname = "seeram";
           //string fullName = c.GetFullName();
           //Console.WriteLine(fullName);

            string fullName = c.ToString();
            Console.WriteLine(fullName);

        }
        
    }

    class Customer
    {
        public string fname { get; set; }

        public string lname { get; set; }

        public override string ToString()
        {
            return this.fname + " " + this.lname;
        } 

        //public string GetFullName()
        //{
        //    return this.fname + " " + this.lname;
        //}
    }

	//Here while invoking Customer class through its instance by calling tostring() method it will always call the overrided method and thus provides the fullName everytime through customer class.

58.Override object.Equals Method::
		   class Program
    {
        static void Main(string[] args)
        {
            Customer c1 = new Customer();
            c1.fname = "Kiran";
            c1.lname = "seeram";

            Customer c2 = new Customer();
            c2.fname = "Kiran";
            c2.lname = "seeram";

	    Customer c3=c2 // c3==c2 && c3.Equals(c2) returns true.
		
            Console.WriteLine(c1==c2);
            Console.WriteLine(c1.Equals(c2));
        }
        
    }

    class Customer
    {
        public string fname { get; set; }

        public string lname { get; set; }

        public override bool Equals(object obj)
        {
            if(obj==null)
            {
                return false;
            }
            else if(!(obj is Customer))
            {
                return false;
            }
            return this.fname == ((Customer)obj).fname && this.lname == ((Customer)obj).lname;
        }

        public override int GetHashCode()
        {
            return this.fname.GetHashCode() ^ this.lname.GetHashCode();
        }
    }



	//while checking the equality for the value types and reference types the (==) && obj1.equals(obj2) both does the same functionality.
	//while checking the equality for the reference types there are 2 things::
	1.Referencing object Equality checking
	2.obect values checking from both the objects.
	//hence we cannot modify the (==) operator so we can modify the object1.Equals(object2) by overriding the base object function.
	//It is mandatory that while overriding the equals method, we have to override the GetHashCode() functionality.


59. diff b/w Convert.toString() and toString() functionality::

    class Program
    {
        static void Main(string[] args)
        {
            Customer c = null;
            Console.WriteLine(c.ToString());//doesnot checks for the 		error handling for null values and throws the 		nullReference Exception.
            Console.WriteLine(Convert.ToString(c));//Handles Error 							Handling
        }
        
    }

    class Customer
    {
        public string fname { get; set; }

        public string lname { get; set; }

       
    }	

60.Diff b/w stringBuilder and string
	strings are immutable objects.
	StringBuilder is an mutable object.
		
    class Program
    {
        static void Main(string[] args)
        {
            string str = "c#";
            str += " Video";
            str += " Training";
            str += " Tutorials";

            Console.WriteLine(str);

            Console.WriteLine();

            StringBuilder stb = new StringBuilder("c#");
            stb.Append(" Video");
            stb.Append(" Training");
            stb.Append(" Tutorials");

            Console.WriteLine(stb.ToString());
        }
        
    }

	//Here, in a string variable the "str" variables is assigned 		mutlitple times.
	//First the str variable is assigned with "c#";
	while updating the str variable with new value the "c#" value 		remains in the heap and a new value "c# videos" is created in 		the Heap.
	//Hence, there will be multiple str values in the Heap, and 	the variable is going to point one and only one value::
	"C# Video Training Tutorials"
	//By creating the string Builder it is going to point only one 	value and it is going to update that one particular value.
	only.
	//Therefore, whenever a string is going to update for multiple 	times then it is wise to go for the string builder
	//The string builder is present in //System.Text; namespace
	//The string class is present in System namespace.

61.Partial class::partial class is used to split the class into 2 or more physical files all these files are combined into one file after the compilation.partial keyword is used to split the struct or interface.

	Ex:aspx--there will be 2 files under aspx file
			--aspx.cs--used for coding
			--aspx.designer.cs--used for declaration.

62.Rules for partial classes::
	1.All the parts spread across different files must specify the 	partial keyword
	2.All the parts must specify the same access modifiers.
	3.if any of the parts specify the abstract keyword then the 		entire file is abstract.
	4.If any of the parts is sealed then the entire type is 	considered as sealed.
	5.If any of the parts is inherited then the entire type is 	inherited.
	6.c# doesn't support multiple class inheritance.different parts of the class must not inherit different base class.suppose if part 1 inherits Customer class and if part 2 includes Employee class and at the end both these are combined into a single file thus it inherits from two different classes Customer and Employee which often leads to multiple class inheritance.
	7.Different partial classes can implement multiple interfaces.
and the final type must implement all the methods of all the interfaces.
	Ex: partial classes are -- SamplePartialClassOne
				-- SamplePartialClassTwo
		    interfaces are -- ICustomer,IEmployee
			Methods are -- ICustomer -- CustomerMethod()
				    -- IEmployee -- EmployeeMethod()
	SamplePartialClassOne is inherting ICustomer
	SamplePartialClassTwo is inherting IEmployee
	Then both of the partial classes must implement the both of the methods.
	Ex:if samplePartialClassOne is implementing Customer Method and if SamplePartialClassTwo is implementing both of the methods Customer and Employee Methods it will throw CT Error because as this method is implemented in one of the partial classes.
	8.Any Methods that are defined in one of the partial classes are allowed to access in another partial classes and the other partial class members are allowed to access in the current partial class.

63.Partial Methods::
	1.A partial Method must contain in an partial class or partial struct.
	2.Partial method must be created with partial keyword.
	3.A partial method declaration consists of 2 parts
		1.Method declaration
		2.Method Implementation.
	These can be in seperate files are in the same file.
	it is an CT Error to provide the method declaration and implementation in the same place.
	partial void Method()
	{
	//lines
	}
	Above code is an CT error.The actual code is as follows::
	partial void Method();
	partial void Show()
	{
	//lines
	}--This is valid
	4.The implementation for a partial method is optional.If we don't provide the implementation then compiler skips the signature and calls to that method.
	partial void Show();
	public void Print()
	{
	cw("Print Method");
	Show();//while calling the Show Method it is not implemented 		However, the compiler skips the calling to that function.  
	}
	5.Partial methods are private by default, it is CT error to include private also.
	6.It is a CT error to include the implementation and declaration at the same time.
	partial void Method()
	{
	//lines
	}--This shows CT error.
	7.A partial method return type should be void including any other return type is CT error.
	8.Signature of the partial method declaration must match with the signature of the partial method implementation.
	9.A partial method can be implemented only once. trying to implement in multiple places is an CT error.
	10.A partial method cannot have 	abstract,sealed,virtual,extern,override,new keywords

64.Indexers::
	indexers allow instances of class to be indexed just like arrays.
	Ex::Session variables
		Session["session1"]="Session1 started";
		cw("Session 1 = {0}",Session["session1"]);
		cw("Session 1 = {0}",Session[0]);
	    syntax:: it is same as properties
		public string this[int employeeId]
		{
			get {}
			set {}
		}

65.Indexer Example::
			  class Program
    {
        static void Main(string[] args)
        {
            Company c = new Company();
            Console.WriteLine("Employee with Id:1 = "+c[1]);
            Console.WriteLine("Employee with Id:2 = " + c[2]);
            Console.WriteLine("Employee with Id:3 = " + c[3]);

            c[1] = "Seeram Kiran Kumar";
            Console.WriteLine("Employee with Id:1 = " + c[1]);// To change the Value
        }
    }

    public class Company
    {
        List<Employee> listEmployees { get; set; }
        public Company()
        {
            listEmployees = new List<Employee>();
            listEmployees.Add(new Employee { Id = 1, fname = "Kiran", Gender = "Male" });
            listEmployees.Add(new Employee { Id = 2, fname = "Sandy", Gender = "Male" });
            listEmployees.Add(new Employee { Id = 3, fname = "Vinny", Gender = "Female" });
        }

        public string this[int employeeId]
        {
            get
            {
                return listEmployees.FirstOrDefault(emp => emp.Id == employeeId).fname;
            }
            set
            {
                listEmployees.FirstOrDefault(emp => emp.Id == employeeId).fname = value;
            }
        }
    }

    public class Employee
    {
        public int Id { get; set; }

        public string fname { get; set; }

        public string Gender { get; set; }
    }

66.Indexer overloading::
	Indexers can be overloaded based on number and type of parameters.
	Example program::
			   class Program
    {
        static void Main(string[] args)
        {
            Company c = new Company();
            Console.WriteLine("Employee with Id:1 = "+c[1]);
            Console.WriteLine("Employee with Id:2 = " + c[2]);
            Console.WriteLine("Employee with Id:3 = " + c[3]);

            c[1] = "Seeram Kiran Kumar";
            Console.WriteLine("Employee with Id:1 = " + c[1]);// To change the Value

            Console.WriteLine("Male Employee Count = {0}",c["Male"]);
            Console.WriteLine("Female Employee Count = {0}", c["Female"]);

            //Changing the Gender

            c["Male"] = "Female";
            Console.WriteLine("Male Employee Count = {0}", c["Male"]);
            Console.WriteLine("Female Employee Count = {0}", c["Female"]);

        }
    }

    public class Company
    {
        List<Employee> listEmployees { get; set; }
        public Company()
        {
            listEmployees = new List<Employee>();
            listEmployees.Add(new Employee { Id = 1, fname = "Kiran", Gender = "Male" });
            listEmployees.Add(new Employee { Id = 2, fname = "Sandy", Gender = "Male" });
            listEmployees.Add(new Employee { Id = 3, fname = "Vinny", Gender = "Female" });
        }

        public string this[int employeeId]
        {
            get
            {
                return listEmployees.FirstOrDefault(emp => emp.Id == employeeId).fname;
            }
            set
            {
                listEmployees.FirstOrDefault(emp => emp.Id == employeeId).fname = value;
            }
        }

        public string this[string Gender]
        {
            get
            {
                return listEmployees.Count(emp => emp.Gender == Gender).ToString();
            }
            set
            {
                foreach (Employee item in listEmployees)
                {
                    item.Gender = value;
                }
            }
        }
    }

    public class Employee
    {
        public int Id { get; set; }

        public string fname { get; set; }

        public string Gender { get; set; }
    }

67.There are 4 ways that are used to make method parameters optional
	1.params keyword
	2.method overloading
	3.Default parameters
	4.Optional parameters
	
	1.params keyword::
		class Program
    {
        static void Main(string[] args)
        {

            Add(10, 20);
        }

        public static void Add(int firstNumber,int secondNumber,params int[] RestOfNumbers)
        {
            int result = firstNumber + secondNumber;
            if(RestOfNumbers!=null)
            {
                foreach (int item in RestOfNumbers)
                {
                    result += item;
                }
            }
            Console.WriteLine("Result = {0}",result);
        }

    }

	//Here for Add Method we have passed only 2 parameters 10,20 but there is a third parameter in the function definition with params keyword.Eventhough if we not passed the third parameter it will not throw any CT error because if we provide the params then passing the parameters is optional.

68.Making method parameters optional with method overloading::
		   class Program
    {
        static void Main(string[] args)
        {

            Add(10, 20);
        }

        public static void Add(int firstNumber, int secondNumber, int[] RestOfNumbers)
        {
            int result = firstNumber + secondNumber;
            if (RestOfNumbers != null)
            {
                foreach (int item in RestOfNumbers)
                {
                    result += item;
                }
            }
            Console.WriteLine("Result = {0}", result);
        }
        public static void Add(int firstNumber,int secondNumber)
        {
            Add(firstNumber,secondNumber,null);
        }



    }

	//Here it is a CT error if we not pass the third parameter.hence, we will provide a method which takes 2 parameters and with in that parameter we'll call the actual method and make the third parameter actually passing the "null" value.
	//There will be 2 methods if we want to pass more than 2 parameters then call the actual method.


69.By Passing Default parameters::
		   class Program
    {
        static void Main(string[] args)
        {

            Add(10, 20);
        }

        public static void Add(int firstNumber, int secondNumber, int[] RestOfNumbers=null)
        {
            int result = firstNumber + secondNumber;
            if (RestOfNumbers != null)
            {
                foreach (int item in RestOfNumbers)
                {
                    result += item;
                }
            }
            Console.WriteLine("Result = {0}", result);
        }
 
    }

	//the default parameters is that in the method definition we'll give the default parameter.If the user didn't pass that parameter then the parameter which we given as default will be called.
	//the default parameter must appear after all the required parameters otherwise,it is a CT error.

	Named Parameters::
		If we want to pass the parameters and the method definition itself is an default parameter implementation then we can pass our required parameters by calling the name of that parameter(delimited by :) as follows::Show(1, c:10);
	thus ignoring all other of the parameters.


			class Program
    {
        static void Main(string[] args)
        {

            Show(1, c:10);
        }

       public static void Show(int a,int b=2,int c=5)
        {
            Console.WriteLine("a = {0}",a);
            Console.WriteLine("b = {0}", b);
            Console.WriteLine("c = {0}", c);
        }
 
    }


70.By making the method parameters optional::
	To make a method parameter optional we need to include
	System.Runtime.InteropServices in the program.
	//give the extra attribute beside the parameter as [Optional] or [OptionalAttribute]-- the attribute keyword is optional here.

		 class Program
    {
        static void Main(string[] args)
        {

            Add(10, 20);
        }

        public static void Add(int firstNumber, int secondNumber,[Optional] int[] RestOfNumbers)
        {
            int result = firstNumber + secondNumber;
            if (RestOfNumbers != null)
            {
                foreach (int item in RestOfNumbers)
                {
                    result += item;
                }
            }
            Console.WriteLine("Result = {0}", result);
        }
 
    }


71.	



















